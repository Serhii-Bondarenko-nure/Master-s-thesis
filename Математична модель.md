### Workflow (DAG) Model
Розглядається задача планування **workflow**, представлена у вигляді орієнтованого ациклічного графа (Directed Acyclic Graph, DAG):
$$
G=(V,E),
$$
де:
- $V = {v_1, v_2, …, v_n}$ — множина задач (вузлів графа).
- $E ⊆ V × V$ — множина залежностей між задачами.
Наявність ребра $(v_i,v_j)\in E$ означає, що задача $v_j$​ може розпочатися лише після завершення задачі $v_i$​.
### Task Attributes
Кожна задача $v_i \in V$ описується кортежем:
Для кожної задачі:
$$
v_i=(id_i,level_i,type_i),
$$
де:
- $id_i$​ — унікальний ідентифікатор задачі;
- $level_i$​ — топологічний рівень задачі у DAG;
- $type_i \in \{compute,merge,io\}$ — тип задачі.
Топологічний рівень визначається рекурсивно:
$$
level_i= \begin{cases}
	o, & \text{if pred}(v_i) = \varnothing, \\
	\max\limits_{v_j \in pred(v_i)} (level_j)+1, & otherwise,​
\end{cases}
$$
де $pred(v_i)$ — множина безпосередніх попередників задачі $v_i$​.
### Communication Model
Кожне ребро $(v_i, v_j) \in E$ асоціюється з обсягом переданих даних:
$$
e_{i,j}=(v_i,v_j,data\_size_{i,j}),
$$
де $data\_size_{i,j}​$ — кількість даних, які передаються від задачі $v_i$​ до задачі $v_j$​.

Комунікаційна затримка між задачами визначається як:
$$
Comm_{i,j}= \begin{cases}
	\frac{data\_size_{i,j}}{B}, & \text{if p}_i \neq p_j, \\
	0, & \text{if p}_i=p_j,
\end{cases}
$$
де:
- $B$ — пропускна здатність міжпроцесорного каналу;
- $p(i)$ — процесор, на який призначена задача $v_i$​.
### Computational Weight of Tasks
Кожній задачі $v_i$​ відповідає її обчислювальна складність $W_i$​, яка визначається як функція її атрибутів:
$$
W_i=f(type_i,level_i),
$$
де функція $f(\cdot)$ задається наступним чином:
$$
W_i= \begin{cases}
	\alpha \cdot g(level_i) & \text{if type}_i=compute, \\
	\beta \cdot g(level_i) & \text{if type}_i=merge, \\
		\gamma & \text{if type}_i=io,
\end{cases}
$$
де:
- $\alpha, \beta, \gamma$ — коефіцієнти складності;
- $g(level_i)$ — монотонно зростаюча функція, що відображає збільшення складності задачі з ростом глибини DAG.
### Platform Model
Паралельна обчислювальна система моделюється множиною процесорів:
$$
P=\{p_1​,p_2​,…,p_m​\}.
$$
Кожен процесор $p_j$​ характеризується своєю відносною продуктивністю:
$$
pj​=(speedj​),
$$
де $speed_j > 0$ — коефіцієнт швидкодії процесора.
### Expected Time to Compute (ETC) Matrix
Матриця очікуваного часу виконання задач має вигляд:
$$
ETC=[ETC(i,j)]_{n \times m},
$$
де елемент $ETC(i,j)$ визначає час виконання задачі $v_i$​ на процесорі $p_j$​ і обчислюється як:
$$
ETC(i,j)= \frac{​W_i}{speed_j}\cdot(1+ε_{i,j​}),
$$
де:
- $ε_{i,j​}$ — випадкове збурення, що моделює варіативність виконання.
### Scheduling Constraints and Performance Metrics
#### Task Timing Constraints
Час початку виконання задачі $v_i$​ визначається як:
$$
EST(v_i)=\max\limits_{v_j \in pred(v_i)} (FT(v_j)+Comm(j,i)),
$$
де $FT(v_j)$ — час завершення задачі $v_j$​.
Час завершення задачі:
$$
FT(v_i​)=EST(v_i​)+ETC(i,p(i)),
$$
де $p(i)$ — процесор, на який призначена задача $v_i$​.
#### Makespan
Загальний час виконання workflow (makespan) визначається як:
$$
Makespan=\max\limits_{v_i \in V} FT(v_i).
$$
#### Average Task Completion Time
Середній час завершення задач визначається як:
$$
AvgCompletionTime= \frac{1}{|V|} \sum\limits_{v_i \in V}FT(v_i​).
$$
Ця метрика дозволяє оцінити **загальну затримку виконання задач** незалежно від критичного шляху.
#### Load Balancing Metric
Навантаження процесора $p_j$​ визначається як сумарний час виконання задач, призначених цьому процесору:
$$
Load_j=\sum\limits_{v_i \in V_j}ETC(i,j​),
$$
де $V_j$​ — множина задач, призначених процесору $p_j$​.

Середнє навантаження процесорів::
$$
\overline{Load}=\frac{1}{m}\sum\limits^{m}\limits_{j=1}Load_j.
$$
##### Standard Deviation–based Load Balance
Стандартне відхилення навантаження визначається як:
$$
LB_{std}=\sqrt{\frac{1}{m}\sum\limits^{m}\limits_{j=1}(Load_j-\overline{Load})^2}.
$$
Менше значення $LB_{std}$ відповідає **кращому балансуванню навантаження** між процесорами.
##### Coefficient of Variation–based Load Balance
Для нормалізованої оцінки балансування навантаження використовується **коефіцієнт варіації**:
$$
LB_{cv}=\frac{LB_{std}}{\overline{Load}}.
$$
Коефіцієнт варіації дозволяє:
- порівнювати результати для різної кількості процесорів;
- уникати залежності метрики від абсолютних масштабів навантаження;
- коректно аналізувати гетерогенні платформи.
**Менше значення $LB_{cv}$​** означає **краще балансування навантаження**.

## Представлення даних
### Структура вхідних даних
Для проведення експерименту, створену математичну модель необхідно зв'язати з кодом, для чого і було створено відповідне подання даних. Дана структура даних описує окремий набір вхідних даних, яких у сценарії може бути більше одного.
Структура даних складається з трьох основних блоків:
- **processors** - кластер процесорів, згенерований для експерименту.
- **ETC** (*Expected Time to Compute*) - матриця значень очікуваного часу обчислення задач.
- **DAG** (*Directed Acyclic Graph*) - контекст ациклічного направленного графу.

Як формат зберігання даних був обраний *JSON*, через його простоту, наочність та розширюваність.
Нижче представлено повну схему представлення даних у форматі *JSON*.
```json
{
  "processors": [
    { "id": 0, "speed": 1.0 },
    { "id": 1, "speed": 1.3 },
    { "id": 2, "speed": 1.8 }
  ],

  "ETC": [
    [12.0, 9.5, 7.8],
    [25.0, 19.2, 16.1],
    [40.0, 32.5, 28.0],
    [18.0, 14.0, 11.5]
  ],

  "DAG": {
    "dag_meta": {
      "type": "layered_fork_join",
      "num_tasks": 4,
      "max_level": 2,
      "avg_parallelism": 6,
      "critical_path_length": 9,
      "communication_model": {
        "model": "bandwidth",
        "bandwidth": 100.0
      }
    },

    "tasks": [
      { "id": 0, "level": 0, "type": "io" },
      { "id": 1, "level": 1, "type": "compute" },
      { "id": 2, "level": 1, "type": "compute" },
      { "id": 3, "level": 2, "type": "merge" }
    ],

    "edges": [
      { "from": 0, "to": 1, "data_size": 120.0 },
      { "from": 0, "to": 2, "data_size": 100.0 },
      { "from": 1, "to": 3, "data_size": 200.0 },
      { "from": 2, "to": 3, "data_size": 180.0 }
    ]
  }
}
```

Блок **processors** - це масив об'єктів, які описують кожний процессор у кластері.
Кожен об'єкт має такі поля:
- *id* - ідентифікатор процессору.
- *speed* - швидкість роботи процессору.
```json
"processors": [
    { "id": 0, "speed": 1.0 },
    { "id": 1, "speed": 1.3 },
    { "id": 2, "speed": 1.8 }
  ]
```

Блок **ETC** представлений у вигляді матриці, де рядки – це окремі завдання, а стовпці – час виконання цих завдань на процесорах із кластера.
```json
"ETC": [
    [12.0, 9.5, 7.8],
    [25.0, 19.2, 16.1],
    [40.0, 32.5, 28.0],
    [18.0, 14.0, 11.5]
  ]
```

Блок **DAG** складається з трьох об’єктів:
- *dag_meta* - метадані графа.
- *tasks* - список завдань.
- *edges* - массив граней або ребер, описуючих залежність у графі.
```json
"DAG": {
    "dag_meta": {
      "type": "layered_fork_join",
      "num_tasks": 4,
      "max_level": 2,
      "avg_parallelism": 6,
      "critical_path_length": 9,
      "communication_model": {
        "model": "bandwidth",
        "bandwidth": 100.0
      }
    },

    "tasks": [
      { "id": 0, "level": 0, "type": "io" },
      { "id": 1, "level": 1, "type": "compute" },
      { "id": 2, "level": 1, "type": "compute" },
      { "id": 3, "level": 2, "type": "merge" }
    ],

    "edges": [
      { "from": 0, "to": 1, "data_size": 120.0 },
      { "from": 0, "to": 2, "data_size": 100.0 },
      { "from": 1, "to": 3, "data_size": 200.0 },
      { "from": 2, "to": 3, "data_size": 180.0 }
    ]
  }
```

Объект **dag_meta** содержит такие поля:
- *type* - структура DAG.
- *num_tasks* - кількість задач.
- *max_level* (або *max_depth*) - глибина DAG.
- *avg_parallelism* - середня ширина.
- *critical_path_length* - аналіз складності.
- *communication_model* - об'єкт з описом моделі зв’язку.
```json
"dag_meta": {
      "type": "layered_fork_join",
      "num_tasks": 4,
      "max_level": 2,
      "avg_parallelism": 6,
      "critical_path_length": 9,
      "communication_model": {
        "model": "bandwidth",
        "bandwidth": 100.0
      }
    }
```

Об'єкт **tasks** - це масив об'єктів, які описують завдання та мають такі поля:
- *id* - ідентифікатор задачі, відповідає завданню з матриці **ETC**
- *level* -відповідає фазам обчислень, необхідний для генерації DAG, евристик та аналізу паралелізму.
- *type* - тип задачі; за замовчуванням є три типи завдань:
	- *compute* - чисто обчислювальна задача
	- *merge* - об'єднання результатів (join)
	- *io* - ввід/вивід або передача
```json
"tasks": [
      { "id": 0, "level": 0, "type": "io" },
      { "id": 1, "level": 1, "type": "compute" },
      { "id": 2, "level": 1, "type": "compute" },
      { "id": 3, "level": 2, "type": "merge" }
    ]
```

Об'єкт **edges** є масивом об'єктів, які описують залежність у графі. Кожна залежність має такі поля:
- *from* - поточне завдання.
- *to* - наступне завдання.
- *data_size* - обсяг даних, що передається між задачами.

```json
"edges": [
      { "from": 0, "to": 1, "data_size": 120.0 },
      { "from": 0, "to": 2, "data_size": 100.0 },
      { "from": 1, "to": 3, "data_size": 200.0 },
      { "from": 2, "to": 3, "data_size": 180.0 }
    ]
```
